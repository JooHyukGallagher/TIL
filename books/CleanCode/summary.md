## 2. 의미 있는 이름

### 의도를 분명히 밝혀라
의도가 분명하게 이름을 지어라
```java
int elapsedTimeInDays;
int daysSinceCreation;
int daysSinceModification;
int fileAgeInDays;
```
### 그릇된 정보를 피하라
여러 계정을 그룹으로 묶을 때, 실제 List가 아니라면, accountList라 명명하지 않는다. 일관성이 떨어지는 표기법은 그릇된 정보다.

### 의미 있게 국분하라
연속된 숫자를 덧붙이거나 불용어(noise word)를 추가하는 방식은 적절하지 못하다. Product라는 클래스가 있다고 가정하자. 다른 클래스를 ProductInfo 혹은 ProductData라 부른다면 개념을 구분하지 않은 채 이름만 달리한 경우이다. Info나 Data는 a, an, the와 마찬가지로 의미가 불분명한 불용어다. 읽는 사람이 차이를 알도록 이름을 지어라.

### 발음하기 쉬운 이름을 사용하라

### 검색하기 쉬운 이름은 사용하라
이름 길이는 범위 크기에 비례해야 한다.

### 인코딩을 피하라
클래스와 함수는 접두어가 필요없을 정도로 작아야 마땅하다.

### 자신의 기억력을 자랑하지 마라
전문가 프로그래머는 명료함이 최고라는 사실을 이해한다.

### 클래스이름에 동사는 사용하지 않는다.

### 메서드 이름
생성자를 중복정의 할 때는 정적 팩토리 메서드를 사용한다. 

```java
Complex fulcrumPoint = Complex.FromRealNumber(23.0);
```
위 코드가 아래 코드보다 좋다.
```java
Complex fulcrumPoint = new Complex(23.0);
```

### 기발한 이름은 피하라

### 한 개념에 한 단어를 사용하라

### 말장난을 하지 마라

### 해법 영역에서 가져온 이름을 사용하라

### 문제 영역에서 가져온 이름을 사용하라

### 의미 있는 맥락을 추가하라

### 불필요한 맥락을 없애라

<hr>

## 3. 함수

### 작게 만들어라!
함수를 만드는 첫째 규칙은 '작게!'다. 함수를 만드는 둘째 규칙은 '더 작게!'다.

### 블록과 들여쓰기
if 문/ else 문/ while 문 등에 들어가는 블록은 한 줄이어야 한다. 이 말은 중첩 구조가 생길만큼 함수가 커져서는 안 된다는 뜻이다. 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.

### 한 가지만 해라!
> 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.
<br>

지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.
<br>

함수가 '한 가지'만 하는지 판단하는 방법이 하나 더 있다. 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.

### 함수 당 추상화 기준은 하나로!

### 위에서 아래로 코드 읽기: 내려가기 규칙
코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 핵심은 짧으면서도 '한 가지'만 하는 함수다.

### Switch문
일반적으로 저자는 switch 문을 단 한번만 참아준다. 

### 서술적인 이름을 사용하라!
코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다.
<br>
이름이 길어도 괜찮다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.

### 함수 인수
함수에서 이상적인 인수 개수는 0개(무항)다.
<br>
최선은 입력 인수가 없는 경우이며, 차선은 입력 인수가 1개뿐인 경우다.

#### 많이 쓰는 단항 형식
입력 인수를 변환하는 함수라면 변환 결과는 반환값으로 돌려준다.

```java
StringBuffer transform(StringBuffer in)
```
위 코드가 아래 코드 보다 좋다.
```java
void transform(StringBuffer out) 
```

#### 플래그 인수
함수로 부울 값을 넘기는 관례를 정말로 끔찍하다.

#### 이항 함수
가능하면 이항 함수를 단항 함수로 바꾸도록 애써야 한다.

#### 삼항 함수
삼항함수를 생성한 때 신중하게 고려하라 권고한다.

#### 인수 객체
인수 2-3개가 필요하다면 일부를 독자적인 클래스로 변수로 선언할 가능성을 짚어 본다.

```java
Circle makeCircle(double x, double y, double radius);
Circle makeCircle(Point center, double radius);
```

### 부수 효과를 일으키지 마라!

### 명령과 조회를 분리해라!
함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다.

### 오류 코드보다 예외를 사용하라!
try/catch블록은 원래 추하다. 코드 구조에 혼란을 일으키며, 정상 동작과 오류처리 동작을 뒤섞는다. 그러므로 try/catch 블록을 별도 함수로 뽑아내는 편이 좋다.

#### 오류 처리도 한 가지 작업이다.
오류 처리도 '한 가지' 작업에 속한다. 그러므로 오류를 처리하는 함수는 오류만 처리해야 마땅하다.
<br>
오류 코드 대신 예외를 사용하면 새 예외는 Exception 클래스에서 파생된다. 따라서 재컴파일/재배치 없이도 새 예외 클래스를 추가할 수 있다.

### 반복하지 마라!

### 구조적 프로그래밍
함수를 작게 만든다면 간혹 return, break, continue를 여러 차례 사용해도 괜찮다.

### 결론
대가(master) 프로그래머는 시스템을 (구현할) 프로그램이 아니라 (풀어갈) 이야기로 여긴다.

<hr>

## 4. 주석

> 코드만이 자기가 하는 일을 진실되게 말한다.

### 주석은 나쁜 코드를 보완하지 못한다.

### 코드로 의도를 표현하라!

### 좋은주석
* 법적인 주석
* 정보를 제공하는 주석
* 의도를 설명하는 주석
* 의미를 명료하게 밝히는 주석
* 결과를 경고하는 주석
* TODO 주석
* 중요성을 강조하는 주석
* 공개 API에서 javadocs

### 나쁜주석
* 주절거리는 주석
* 같은 이야기를 중복하는 주석
* 오해할 여지가 있는 주석
* 의무적으로 다는 주석
* 이력을 기록하는 주석
* 있으나 마나 하나 주석
* 무서운 잡음
* 함수나 변수로 표현할 수 있다면 주석을 달지 마라
* 위치를 표시하는 주석
* 닫는 괄호에 다는 주석(닫는 괄호에 주석을 달아야겠다는 생각이 든다면 대신에 함수를 줄이려 시도하자.)
* 공로를 돌리거나 저자를 표시하는 주석
* 주석으로 처리한 코드
* HTML 주석
* 전역 정보(주석을 달아야 한다면 근처에 있는 코드만 기술하라.)
* 너무 많은 정보
* 모호한 관계
* 함수 헤더(짧은 함수는 긴 설명이 필요 없다. 짧고 한가지만 수행하며 이름을 잘 붙인 함수가 주석으로 헤더를 추가한 함수보다 훨씬 좋다.)
* 비공개 코드에서 Javadocs

<hr>

## 5. 형식 맞추기
### 적절한 행 길이를 유지하라
500줄을 넘지 않고 대부분 200줄 정도인 파일로도 커다란 시스템을 구축할 수 있다.
### 신문 기사처럼 작성하라
이름은 간단하면서도 설명이 가능하게 짓는다. 이름만 보고도 올바른 모듈을 살펴보고 있는지 아닌지를 판단할 정도로 신경 써서 짓는다. 소스 파일 첫 부분은 고차원 개념과 알고리즘을 설명한다. 아래로 내려갈수록 의도를 세세하게 묘사한다.
### 개념은 빈 행으로 분리하라
### 세로 밀집도
줄바꿈이 개념을 분리한다면 세로 밀집도는 연관성을 의미한다. 즉, 서로 밀집한 코드 행은 세로로 가까이 놓여야 한다는 뜻이다.
### 수직 거리
서로 밀접한 개념은 세로로 가까이 둬야 한다.
### 변수 선언
변수는 사용하는 위치에 최대한 가까이 선언한다.
### 인스턴스 변수
인스턴스 변수를 클래스 맨 처음에 선언한다.
### 종속 함수
한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다. 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다.
### 개념적 유사성
친화도가 높을수록 코드를 가까이 배치한다.
### 가로 형식 맞추기
프로그래머는 명백하게 짧은 행을 선호한다. 120자 정도로 행 길이를 제한한다.

## 6. 객체와 자료구조
### 자료 추상화
변수를 pirvate으로 선언하더라도 각 값마다 조회(get) 함수와 설정(set) 함수를 제공한다면 외부로 노출하는 셈이다. 구현을 감추려면 추상화가 필요하다!
<br>
추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다.
<br>
자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋다.

### 자료/객체 비대칭
객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.
<br>
절차적인 코드는 기존 자료구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.
<br><br>
복잡한 시스템을 짜다 보면 새로운 함수가 아니라 새로운 자료 타입이 필요한 경우가 생긴다. 이때는 클래스와 객체 지향 기법이 가장 적합하다. 반면, 새로운 자료 타입이 아니라 새로운 함수가 필요한 경우도 생긴다. 이때는 절차적인 코드와 자료 구조가 좀 더 적합하다.
<br>
분별 있는 프로그래머는 모든 것이 객체라는 생각이 미신임을 잘 안다. 때로는 단순한 자료 구조와 절차적인 코드가 가장 적합한 상황도 있다.

### 디미터 법칙
디미터 법칙은 잘 알려진 휴리스틱으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다.
#### 잡종 구조
절반은 객체, 절반은 자료 구조인 잡종 구조는 되도록이면 피하는 편이 좋다. 프로그래머가 함수나 타입을 보호할지 공개할지 확신하지 못해 (더 나쁘게는 무지해) 어중간하게 내놓은 설계에 불과하다.

### 자료 전달 객체
자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다. 이런 자료 구조체를 DTO라 한다.
#### 활성 레코드
활성 레코드는 DTO의 특수한 형태이다. 활성 레코드는 자료 구조로 취급한다. 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성한다.

### 결론
객체는 동작을 공개하고 자료를 숨긴다. 그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면, 기존 객체에 새 동작을 추가하기는 어렵다. 자료 구조는 별다른 동작 없이 자료를 노출한다. 그래서 기존 자료 구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다.
<br><br>
어떤 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. 다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다. 우수한 소프트웨어 개발자는 편견없이 이 사실을 이해해 직면한 문제에 최적인 해결책을 선택한다.

## 6. 오류 처리
### 오류 코드보다 예외를 사용하라
### Try-Catch-Finally 문부터 작성하라
먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장한다.
### 미확인 예외를 사용하라
### 예외에 의미를 제공하라
오류 메시지에 정보를 담아 예외와 함께 던진다. 실패한 연산 이름과 실패 유형도 언급한다. 애플리케이션이 로깅 기능을 사용한다면 catch 블록에서 오류를 처리하도록 충분한 정보를 넘겨준다.
### 호출자를 고려해 예외 클래스를 정의하라
### 정상 흐름을 정의하라
### null을 반환하지 마라
메서드에서 null을 반환하고픈 유혹이 든다면 그 대신 예외를 던지거나 특수 사례 객체를 반환한다.
### null을 전달하지 마라
정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 코드는 최대한 피한다.
<br>
대다수 프로그래밍 언어는 호출자가 싫수로 넘기는 null을 적절히 처리하는 방법이 없다. 그렇다면 애초에 null을 넘기지 못하도록 금지하는 정책이 합리적이다. 즉, 인수로 null이 넘어오면 코드에 문제가 있다는 말이다.
